import numpy as np


class Entity:
    def __init__(self, comp_ability, service):
        """
        Args:
            comp_ability: computation ability (Flops/s)
            service: DNN inference service
        """
        self.name = ''
        self.comp_ability = comp_ability
        self.service = service
        # remain task size: represented by data size(bits)
        self.remain_task = 0

    def scripted_action(self, duration):
        """
        scripted actions that each agents would do every time slot
        Args:
            duration: duration of each time slot

        Returns: None

        """
        self.remain_task -= duration * self.comp_ability


# IoT device
class Agent(Entity):
    def __init__(self, comp_ability, service, task_lam=1):
        """
        initialize Agent class
        Args:
            comp_ability: computation ability (Flops/s)
            service: DNN inference service
            task_lam: lambda variable for poisson distribution of task arrival
        """
        super(Agent, self).__init__(comp_ability)
        # channel gain
        self.gain = 0
        self.task_lam = task_lam
        self.service = service
        # discrete action
        self.action = None

    def generate_task(self):
        """
        generate task at the begining of the time slot, arrive data size obey Poisson distribution
        Returns:
            arriving data size of current time slot
        """
        return np.random.poisson(lam=self.task_lam, size=1)[0]


# 5G base station
class BaseStation(Entity):
    def __init__(self, comp_ability, service):
        super(BaseStation, self).__init__(comp_ability, service)
        super(BaseStation, self).name = 'Base Station'


# branchy style DNN model
class BranchyModel:
    def __init__(self, comp_intensities, accuracy, input_data, accuracy_limit):
        """
        Args:
            comp_intensities:  computation intensities(total cycles / input data size) for each branches
            accuracy: accuracy table of all branches
            input_data: input data size(bits)
        """
        self.branches_num = len(comp_intensities)
        self.comp_intensities = comp_intensities
        self.accuracy = accuracy
        self.input_data = input_data
        self.accuracy = accuracy_limit


# DNN inference service
class Service:
    def __init__(self, branchy_model, max_wait_time):
        self.branchy_model = branchy_model
        self.max_wait_time = max_wait_time


class World:
    def __init__(self, agents, bs, duration):
        self.agents = agents
        self.bs = bs
        self.duration = duration

    def step(self):
        """
        update state of the world
        Returns: None

        """
        # TODO: action generated by RL model
        # set actions
        for agent in self.agents:
            agent.scripted_action(self.duration)




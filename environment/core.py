import random
import math
import numpy as np


class Entity:
    def __init__(self, comp_ability, service):
        """
        Args:
            comp_ability: computation ability (Flops/s)
            service: DNN inference service
        """
        self.name = ''
        self.comp_ability = comp_ability
        self.service = service
        # remain task size: represented by data size(bits)
        self.remain_task = 0

    def scripted_action(self, duration):
        """
        scripted actions that each agents would do every time slot: Reduction of remaining tasks
        Args:
            duration: duration of each time slot

        Returns: None

        """
        self.remain_task -= duration * self.comp_ability
        if self.remain_task < 0:
            self.remain_task = 0


# IoT device
class Agent(Entity):
    def __init__(self, comp_ability, service, task_lam=1):
        """
        initialize Agent class
        Args:
            comp_ability: computation ability (Flops/s)
            service: DNN inference service
            task_lam: lambda variable for poisson distribution of task arrival
        """
        super(Agent, self).__init__(comp_ability)
        # channel gain
        self.gain = 0
        self.task_lam = task_lam
        self.service = service
        # discrete action
        self.action = None
        # accuracy sum is used to calculate average accuracy
        self.acc_sum = 0
        # arrived tasks number for next time slot
        self.arrived_tasks = 0
        # the channel gain id
        self.channel_gain_id = 1
        # transmission rate between agent and BS
        self.trans_rate = 0

    def generate_task(self):
        """
        generate task at the begining of the time slot, arrive data size obey Poisson distribution
        Returns: None
        """
        self.arrived_tasks = np.random.poisson(lam=self.task_lam, size=1)[0]

    def is_offloaded(self):
        """
        check whether agent offload task to base station
        Returns: a boolean var that indicates whether agent offload task to base station
        """
        b_model = self.service.branchy_model
        return self.action == b_model.branches_num

    def policy_action(self):
        """
        execute action generated by the RL model(policy)
        Returns:
            is_dropped: a boolean var that shows weather task dropped
            latency: The execution of execute tasks arrived locally
        """
        b_model = self.service.branchy_model
        is_dropped = False
        latency = 0
        if self.is_offloaded():
            # execute locally
            branch_id = self.action  # action indicates the chosen branch id
            comp_intensity = b_model.comp_intensities[branch_id]  # chosen branch's computation intensity
            accuracy = b_model.accuracy[branch_id]  # chosen branch's accuracy
            # update acc_sum
            self.acc_sum += accuracy
            # update task queue
            needed_cycles = comp_intensity * b_model.input_data  # needed cpu cycles for per task
            for _ in range(self.arrived_tasks):
                latency = self.remain_task + needed_cycles / self.comp_ability
                # if arriving task's wait time is bigger than max wait time then drop it
                if latency > self.service.max_wait_time:
                    is_dropped = True
                    break
                else:
                    self.remain_task += needed_cycles
        else:
            # offload to bs
            self.acc_sum += self.service.base_model_acc
        return is_dropped, latency


# 5G base station
class BaseStation(Entity):
    def __init__(self, comp_ability, service):
        super(BaseStation, self).__init__(comp_ability, service)
        super(BaseStation, self).name = 'Base Station'

    def policy_action(self, tasks_num, upload_rates):
        """
        base station receives tasks that offloaded by agents
        Args:
            tasks_num: a list show the offloaded task number of each agents
            upload_rates: a list show the upload rates(bits/s) for each agents
        Returns:
            is_dropped: a boolean number that shows weather tasks are dropped
            latency_list: a list for latency of each agents
        """
        is_dropped = False
        latency_list = []
        agents_num = len(tasks_num)
        pre_remain_task = self.remain_task
        # the sum of arrived data size of all agents
        data_size_sum = sum(tasks_num) * self.service.branchy_model.input_data
        for i in range(agents_num):
            # for agent i
            if tasks_num[i] == 0:
                latency_list.append(0)
                continue  # execute locally
            data_size = tasks_num[i] * self.service.branchy_model.input_data
            upload_time = data_size / upload_rates[i]
            execute_time = data_size * self.service.base_model_ci / self.comp_ability
            accumulate_queue_time = pre_remain_task / self.comp_ability
            cur_avg_wait_time = data_size_sum * self.service.base_model_ci / (2 * self.comp_ability)
            latency = upload_time + execute_time + accumulate_queue_time + cur_avg_wait_time
            latency_list.append(latency)
            if latency > self.service.max_wait_time:
                is_dropped = True
        return is_dropped, latency_list


# branchy style DNN model
class BranchyModel:
    def __init__(self, comp_intensities, accuracy, input_data):
        """
        Args:
            comp_intensities:  computation intensities(total cycles / input data size) for each branches
            accuracy: accuracy table of all branches
            input_data: input data size(bits)
        """
        self.branches_num = len(comp_intensities)
        self.comp_intensities = comp_intensities
        self.accuracy = accuracy
        self.input_data = input_data


# DNN inference service
class Service:
    def __init__(self, name, branchy_model, max_wait_time, accuracy_limit):
        self.name = name
        self.branchy_model = branchy_model
        self.max_wait_time = max_wait_time
        self.base_model_acc = branchy_model.accuracy[-1]
        self.base_model_ci = branchy_model.comp_intensities[-1]  # computation intensity for main branch
        self.acc_limit = accuracy_limit


class World:
    def __init__(self, agents, bs, duration):
        self.agents = agents
        self.bs = bs
        self.duration = duration
        # channel gains are divided to three type, Good:6*10^-13, Normal:4*10^-13, Bad:2*10^-13
        self.channel_gain = [6*pow(10, -13), 4*pow(10, -13), 2*pow(10, -13)]
        # channel gain translation matrix
        self.gain_prob = [[0.3, 0.7, 0], [0.25, 0.5, 0.25], [0, 0.7, 0.3]]
        # white Gaussian noise  -100dBm=10^-13W
        self.white_noise = pow(10, -13)
        # transmit power 20dBm=100mW=0.1W
        self.tran_power = 0.1
        # bandwidth of subchannels
        self.bandwidth = 5

    def step(self):
        """
        update state of the world
        Returns:
            drop_info: a list that shows whether tasks of agents would be dropped
            latency_list: a list that shows totally latency of agent's task execution
        """
        # get updated agents' info
        tasks_to_bs = []
        update_rates = []
        for agent in self.agents:
            if agent.is_offloaded():
                tasks_to_bs.append(agent.arrived_tasks)
            else:
                tasks_to_bs.append(0)
            update_rates.append(agent.trans_rate)
        # update state of the world
        drop_info, latency_list = [], []
        for agent in self.agents:
            is_dropped, latency= agent.policy_action()
            drop_info.append(is_dropped)
            latency_list.append(latency)
            # Execute tasks in agent's waiting queue
            agent.scripted_action(self.duration)
        # Execute tasks in base station's waiting queue
        is_dropped, latency = self.bs.policy_action(tasks_to_bs, update_rates)
        self.bs.scripted_action(self.duration)
        # union info
        for i in range(len(drop_info)):
            drop_info[i] = drop_info[i] | is_dropped[i]
            latency_list[i] += latency[i]
        return drop_info, latency_list

    def update_agents_states(self):
        self.update_channel_gain()
        self.update_trans_rate()

    def update_channel_gain(self):
        """
        make transition of channel gain based on transition matrix for all agents
        Returns: None
        """
        for agent in self.agents:
            tmp = random.uniform(0, 1)
            accumulate_prob = np.cumsum(self.gain_prob[agent.channel_gain_id])
            for i, acc_p in enumerate(accumulate_prob):
                if acc_p >= tmp:
                    agent.channel_gain_id = i
                    break

    # 5G
    def update_trans_rate(self):
        """
        calculate transmission rate of each agents in the case of SIC decoding
        Returns: None
        """
        # count the number of agents of different channel gain type
        counter = {0: 0, 1: 0, 2: 0}
        for agent in self.agents:
            counter[agent.channel_gain_id] += 1
        for agent in self.agents:
            interference = 0  # interference of other agents that share the same channel
            current_gain = self.channel_gain[agent.channel_gain_id]
            for i in range(agent.channel_gain_id):
                interference += self.tran_power * self.channel_gain[i] * counter[i]
            SINR = self.tran_power * current_gain / (self.white_noise + interference)
            agent.trans_rate =  self.shannon_equation(SINR)

    def shannon_equation(self, SINR):
        return self.bandwidth * math.log2(1 + SINR)

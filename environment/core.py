import numpy as np


class Entity:
    def __init__(self, comp_ability, service):
        """
        Args:
            comp_ability: computation ability (Flops/s)
            service: DNN inference service
        """
        self.name = ''
        self.comp_ability = comp_ability
        self.service = service
        # remain task size: represented by data size(bits)
        self.remain_task = 0

    def scripted_action(self, duration):
        """
        scripted actions that each agents would do every time slot: Reduction of remaining tasks
        Args:
            duration: duration of each time slot

        Returns: None

        """
        self.remain_task -= duration * self.comp_ability
        if self.remain_task < 0:
            self.remain_task = 0


# IoT device
class Agent(Entity):
    def __init__(self, comp_ability, service, task_lam=1):
        """
        initialize Agent class
        Args:
            comp_ability: computation ability (Flops/s)
            service: DNN inference service
            task_lam: lambda variable for poisson distribution of task arrival
        """
        super(Agent, self).__init__(comp_ability)
        # channel gain
        self.gain = 0
        self.task_lam = task_lam
        self.service = service
        # discrete action
        self.action = None
        # accuracy sum is used to calculate average accuracy
        self.acc_sum = 0

    def generate_task(self):
        """
        generate task at the begining of the time slot, arrive data size obey Poisson distribution
        Returns:
            arriving data size of current time slot
        """
        return np.random.poisson(lam=self.task_lam, size=1)[0]

    def policy_action(self, action, task_num):
        """
        execute action generated by the RL model(policy)
        Args:
            action: action generated by the RL model, range [0, branches_num+1]
            task_num: number of tasks arrived at current time slot
        Returns:
            is_dropped: a boolean var that shows weather task dropped
            offload_task_num: number of tasks that offloaded to base station
        """
        b_model = self.service.branchy_model
        is_dropped = False
        offload_task_num = 0
        if action < b_model.branches_num:
            # execute locally
            branch_id = action  # action indicates the chosen branch id
            comp_intensity = b_model.comp_intensities[branch_id]  # chosen branch's computation intensity
            accuracy = b_model.accuracy[branch_id]  # chosen branch's accuracy
            # update acc_sum
            self.acc_sum += accuracy
            # update task queue
            needed_cycles = comp_intensity * b_model.input_data  # needed cpu cycles for per task
            for _ in range(task_num):
                # if arriving task's wait time is bigger than max wait time then drop it
                if self.remain_task + needed_cycles / self.comp_ability > self.service.max_wait_time:
                    is_dropped = True
                    break
                else:
                    self.remain_task += needed_cycles
        else:
            # offload to bs
            offload_task_num = task_num
            self.acc_sum += self.service.base_model_acc
        return is_dropped, offload_task_num


# 5G base station
class BaseStation(Entity):
    def __init__(self, comp_ability, service):
        super(BaseStation, self).__init__(comp_ability, service)
        super(BaseStation, self).name = 'Base Station'

    def policy_action(self, tasks_num, upload_rates):
        """
        base station receives tasks that offloaded by agents
        Args:
            tasks_num: a list show the offloaded task number of each agents
            upload_rates: a list show the upload rates(bits/s) for each agents
        Returns:
            is_dropped: a boolean number that shows weather tasks are dropped
            latency_list: a list for latency of each agents
        """
        is_dropped = False
        latency_list = []
        agents_num = len(tasks_num)
        pre_remain_task = self.remain_task
        # the sum of arrived data size of all agents
        data_size_sum = sum(tasks_num) * self.service.branchy_model.input_data
        for i in range(agents_num):
            # for agent i
            if tasks_num[i] == 0: continue  # execute locally
            data_size = tasks_num[i] * self.service.branchy_model.input_data
            upload_time = data_size / upload_rates[i]
            execute_time = data_size * self.service.base_model_ci / self.comp_ability
            accumulate_queue_time = pre_remain_task / self.comp_ability
            cur_avg_wait_time = data_size_sum * self.service.base_model_ci / (2 * self.comp_ability)
            latency = upload_time + execute_time + accumulate_queue_time + cur_avg_wait_time
            latency_list.append(latency)
            if latency > self.service.max_wait_time:
                is_dropped = True
        return is_dropped, latency_list


# branchy style DNN model
class BranchyModel:
    def __init__(self, comp_intensities, accuracy, input_data):
        """
        Args:
            comp_intensities:  computation intensities(total cycles / input data size) for each branches
            accuracy: accuracy table of all branches
            input_data: input data size(bits)
        """
        self.branches_num = len(comp_intensities)
        self.comp_intensities = comp_intensities
        self.accuracy = accuracy
        self.input_data = input_data


# DNN inference service
class Service:
    def __init__(self, branchy_model, max_wait_time, accuracy_limit):
        self.branchy_model = branchy_model
        self.max_wait_time = max_wait_time
        self.base_model_acc = branchy_model.accuracy[-1]
        self.base_model_ci = branchy_model.comp_intensities[-1]  # computation intensity for main branch
        self.acc_limit = accuracy_limit


class World:
    def __init__(self, agents, bs, duration):
        self.agents = agents
        self.bs = bs
        self.duration = duration

    def step(self):
        """
        update state of the world
        Returns: None

        """
        # TODO: action generated by RL model
        # set actions
        for agent in self.agents:
            agent.scripted_action(self.duration)
